1
00:01:02,879 --> 00:01:05,380
皆さん、こんにちは

2
00:01:06,159 --> 00:01:09,600
第3回目のMBSE Podcastへようこそ

3
00:01:09,600 --> 00:01:12,840
私はティム、ホストの一人です

4
00:01:12,840 --> 00:01:18,929
本日は新商品の開封エピソードです

5
00:01:18,929 --> 00:01:21,600
iPhoneよりももっと良いものです

6
00:01:21,600 --> 00:01:24,640
発表されたばかりのSysML v2です

7
00:01:24,640 --> 00:01:28,720
今回は英語のエピソードです

8
00:01:28,720 --> 00:01:37,140
「なぜドイツ語ではなく英語のエピソードなのか？」を
ホストのクリスチャンに聞いてみましょう

9
00:01:37,759 --> 00:01:45,360
まずSysMLについてインターネット上で
得られる情報は少ないです

10
00:01:45,360 --> 00:01:50,615
エド・ザイデヴィッツやサンディ・フリーデンタール
のいくつかのプレゼンテーションがあるのみです

11
00:01:50,615 --> 00:01:55,040
SysML v2は世界的に関心がある
トピックだと思いました

12
00:01:55,040 --> 00:01:57,442
そのため英語で開催することにしました

13
00:01:58,572 --> 00:02:06,479
聴くだけのMBSE Podcastのリスナーは
私たちが何をするか確認できないでしょう

14
00:02:06,479 --> 00:02:09,679
動画がなくても
理解できるようにします

15
00:02:09,679 --> 00:02:13,120
ですので、リスナーの人は
電源をオフにしないでください

16
00:02:13,120 --> 00:02:18,240
たしかに動画の方が
簡単に理解できます

17
00:02:18,240 --> 00:02:21,870
クリスチャン、本日話す内容を
簡単に説明してくれますか？

18
00:02:22,715 --> 00:02:23,715
わかりました

19
00:02:24,560 --> 00:02:30,800
まず、本日行うことの全体像を
確認する必要があると思います

20
00:02:30,800 --> 00:02:32,720
そうして詳細を確認します

21
00:02:32,720 --> 00:02:36,560
これを30～40分の間で行います

22
00:02:36,560 --> 00:02:39,599
あまり詳細なことには進めません

23
00:02:39,599 --> 00:02:43,200
しかし、SysML v2とは何なのかを
示すことはできるでしょう

24
00:02:43,200 --> 00:02:56,000
SysML v2はテキスト表記の言語のため
ある人はプログラミング言語のように感じています

25
00:02:56,000 --> 00:02:59,280
真実はそうではありません

26
00:02:59,280 --> 00:03:03,599
グラフィカル表記も近い未来にサポートされます

27
00:03:03,599 --> 00:03:09,840
テキスト表記はこれまでとは異なる
第二の観点として追加されます

28
00:03:09,840 --> 00:03:13,360
テキスト表記は非常に正確です

29
00:03:13,360 --> 00:03:19,739
例えばModelicaのように、テキスト表記と
グラフィカル表記の切り替えは可能です

30
00:03:19,739 --> 00:03:27,060
モデル化したグラフィック表記を使用してシステムが
実行していることはユーザにとって非常に明確です

31
00:03:30,480 --> 00:03:42,560
テキスト表記に関しては、ステートレス交換形式の
ようなものを持つ機会があるかもしれません

32
00:03:42,560 --> 00:03:47,280
そのような形式ではユーザUUIDがありません

33
00:03:47,280 --> 00:03:59,040
SysMLモデラーが既存のモデルに何かを貼り付ける前に
新規のモデル要素か既存かを決定できません

34
00:03:59,040 --> 00:04:05,200
しかし、これまでのXMIスキーマよりは
よりよく機能するはずです

35
00:04:05,200 --> 00:04:09,881
ティム、開封する箱の中には何があるのですか？

36
00:04:11,730 --> 00:04:23,759
最新の2020年のリリースからGitHubが利用可能です
これまではGoogleドライブでした

37
00:04:23,759 --> 00:04:29,910
これまではGoogleドライブのリンクから
zipファイルを取得していました

38
00:04:29,910 --> 00:04:34,400
現在はGitHubにすべてがあります
GitHubのページを見てしましょう

39
00:04:34,400 --> 00:04:38,457
SysML v2を開発している
SSTというチームがあります

40
00:04:38,457 --> 00:04:43,680
スクリーンを共有して
GitHubを簡単に見てみましょう

41
00:04:43,680 --> 00:04:45,169
少々お待ちください

42
00:05:05,840 --> 00:05:10,503
見つかりました
こちらがGitHubです

43
00:05:10,873 --> 00:05:13,981
SysMLはとても巨大ですので
ティムは探すのに時間がかかってしまいました

44
00:05:17,520 --> 00:05:25,280
SysML提出チームのGitHubチームページです

45
00:05:25,280 --> 00:05:29,820
URLはこちらです
https://github.com/Systems-Modeling

46
00:05:29,820 --> 00:05:35,919
本エピソードの後にURLを置いておきます

47
00:05:35,919 --> 00:05:42,370
5つのパブリックリポジトリと
1つのプライベートリポジトリがあります

48
00:05:42,370 --> 00:05:47,020
私はアクセス権がありますので
プライベートリポジトリが見れます

49
00:05:47,020 --> 00:05:52,320
SysML v1からSysML v2への変換に関する
仕事を担当しているためです

50
00:05:52,320 --> 00:05:59,280
より成熟し次第、それを公開しますが
現状はまだドラフトです

51
00:05:59,280 --> 00:06:01,440
異なるリポジトリが見えます

52
00:06:01,440 --> 00:06:10,050
本日はリリースリポジトリの開封をします

53
00:06:10,050 --> 00:06:12,080
それでは中を見てみましょう

54
00:06:17,520 --> 00:06:24,400
リポジトリをクローンできたり
zipファイルをダウンロードできます

55
00:06:24,400 --> 00:06:28,800
zipファイルにはすべてが含まれています
zipファイルはここにあります

56
00:06:28,800 --> 00:06:33,560
下にスクロールしていくと
READMEがあります

57
00:06:33,560 --> 00:06:40,100
READMEのどこかに
リリースのリンクがあります

58
00:06:40,100 --> 00:06:43,560
リンクをクリックすると
別ページにジャンプします

59
00:06:43,560 --> 00:06:48,050
そこに最新のリリースの
zipファイルがあります

60
00:06:48,050 --> 00:06:49,919
実際には二種類のzipファイルがあります

61
00:06:49,919 --> 00:06:54,240
一つはパイロット実装
もう一つはAPI & Servicesです

62
00:06:54,240 --> 00:06:58,000
本日はパイロット実装を見てみます

63
00:06:58,000 --> 00:07:01,400
クリスチャン、zipを解凍すると
中には何がありますか？

64
00:07:02,160 --> 00:07:04,889
では見てみましょう

65
00:07:04,889 --> 00:07:13,759
スクリーンを共有します
ティムを上書きしたいと思います

66
00:07:13,759 --> 00:07:18,000
さあ、準備ができました

67
00:07:18,000 --> 00:07:28,929
zipファイルを解凍すると
いくつかのフォルダとファイルがあります

68
00:07:28,929 --> 00:07:36,160
175メガバイトもあります

69
00:07:36,160 --> 00:07:38,399
こちらを見てみましょう

70
00:07:38,399 --> 00:07:43,440
マークダウンのREADMEファイルがあります

71
00:07:43,440 --> 00:07:47,759
インストール方法やそれが何なのかの
導入説明のすべてがあります

72
00:07:47,759 --> 00:07:50,800
もちろん使用許諾もあります

73
00:07:50,800 --> 00:07:59,599
すべてのものはSSTメンバの組織の下で
ライセンス化されています

74
00:07:59,599 --> 00:08:01,530
組織はドキュメントに一覧表記されています

75
00:08:01,530 --> 00:08:07,919
特にパイロット実装はModel Driven Solutions
によってライセンス化されています

76
00:08:07,919 --> 00:08:11,759
エドがModel Driven Solutionsで働いており
パイロット実装に大きく貢献しています

77
00:08:11,759 --> 00:08:19,390
ライセンスはクリエイティブ・コモンズです

78
00:08:19,390 --> 00:08:24,000
使用することはできますし
変更することもできると思います

79
00:08:24,000 --> 00:08:27,759
しかし販売等はできません

80
00:08:28,869 --> 00:08:38,159
実はPDFはクリエイティブ・コモンズですが
その他はGNUライセンスです

81
00:08:38,159 --> 00:08:42,640
法的なものは洗練されています

82
00:08:44,400 --> 00:08:49,600
ドキュメントフォルダには
いくつかのドキュメントがあります

83
00:08:49,600 --> 00:08:52,539
すぐに紹介します

84
00:08:52,539 --> 00:08:55,680
それらのドキュメントを詳細に見ます

85
00:08:55,680 --> 00:09:00,240
しかしテキストファイルも巨大です

86
00:09:00,240 --> 00:09:08,000
他にもEclipseとJupyterの巨大な
インストールファイルもあります

87
00:09:08,000 --> 00:09:16,118
どちらもパイロット実装ですので
これらも見る予定です

88
00:09:16,118 --> 00:09:35,040
SysMLのソース同様に言語としてフォルダにある
メタモデルのKerMLのソースがあります

89
00:09:35,040 --> 00:09:43,600
ソースフォルダには多くの例があります
車の例などのいくつかの例もあります

90
00:09:43,600 --> 00:09:54,080
エドやサンディのプレゼンテーションに
ありますので有名な例かもしれません

91
00:09:54,080 --> 00:10:13,930
ご覧の通り振る舞いの例を含んだ
カメラの例などもあります

92
00:10:13,930 --> 00:10:19,940
最後のフォルダはSysMLライブラリです

93
00:10:19,940 --> 00:10:25,950
こちらはまだ十分ではありません

94
00:10:25,950 --> 00:10:36,800
しかしここには"Geometry"フォルダがあり
基本的な幾何学情報を含んでいます

95
00:10:36,800 --> 00:10:52,799
基本的な幾何学情報とは、CADへの適応等の
ドメインナレッジとしてのカバーの仕方です

96
00:10:52,799 --> 00:10:54,367
何か言い忘れていることはありますか、ティム？

97
00:10:56,025 --> 00:11:03,250
いいえ、大丈夫だと思います
実装としてこれから説明する要素は以上です

98
00:11:04,000 --> 00:11:08,910
ティム、ドキュメントのパート1を教えてください

99
00:11:09,360 --> 00:11:14,079
はい、3つのSysML v2の仕様書があります

100
00:11:14,079 --> 00:11:17,839
パート1を見てみましょう

101
00:11:17,839 --> 00:11:21,600
スクリーンを共有します

102
00:11:21,600 --> 00:11:25,600
動画視聴者は見ることができます

103
00:11:25,600 --> 00:11:29,279
私は箱を探さなければなりません

104
00:11:29,279 --> 00:11:33,600
パート1はKerMLの仕様書です

105
00:11:33,600 --> 00:11:40,426
KerMLはSysML v2のための
メタモデルとして選ばれたものです

106
00:11:40,426 --> 00:11:43,709
SysML v1はUMLベースの言語です

107
00:11:43,709 --> 00:11:49,120
SysML v2は全く新しいメタモデルを得ました

108
00:11:49,120 --> 00:11:54,129
こちらがカバーページです

109
00:11:54,129 --> 00:12:03,360
本書は200ページ以上あります
完成するともっと長くなると思います

110
00:12:03,360 --> 00:12:09,520
スコープの章にジャンプしましょう

111
00:12:09,520 --> 00:12:15,360
もしあなたがOMG仕様書を開く場合は
スコープの章から始めるのがよいです

112
00:12:15,360 --> 00:12:18,900
こちらが第1章です

113
00:12:18,900 --> 00:12:24,399
この本のスコープがなんであるかを
読むことができるため興味深いです

114
00:12:24,399 --> 00:12:31,040
KerMLはアプリケーションに依存しない
シンタクスとセマンティクスを提供します

115
00:12:31,040 --> 00:12:34,480
これはより特定のモデリング言語を作ります

116
00:12:34,480 --> 00:12:40,160
これがメタモデルです
SysML v2のための基礎です

117
00:12:40,160 --> 00:12:48,829
メタモデルをよく見てみましょう
メタモデルは洗練されています

118
00:12:48,829 --> 00:12:52,880
例を探してみましょう

119
00:12:52,880 --> 00:13:00,190
こちらは7.3章です
型に関する章です

120
00:13:00,190 --> 00:13:04,720
型はモデリング言語の共通概念です

121
00:13:04,720 --> 00:13:11,514
見ることができない人のために
メタモデルの図を見ています

122
00:13:11,514 --> 00:13:16,079
型を例として見てみます

123
00:13:16,079 --> 00:13:18,200
右側は機能(feature)です

124
00:13:18,200 --> 00:13:21,818
単純に言うと、ブロック(block)と
特性(property)です

125
00:13:21,818 --> 00:13:24,479
機能(feature)の特化した型です

126
00:13:24,479 --> 00:13:28,720
機能(feature)自体が特化した型
ということも確認できます

127
00:13:28,720 --> 00:13:31,760
これはSysML v2で新しいことです

128
00:13:31,760 --> 00:13:33,570
SysML v1にも型や特性(property)はあります

129
00:13:33,570 --> 00:13:42,909
奇妙なことですが、SysML v2の中では
機能(feature)は型それ自体になりえます

130
00:13:42,909 --> 00:13:48,460
こちらに関しては別のエピソードで
議論する価値があると思います

131
00:13:48,460 --> 00:13:53,040
そしてこちらをご覧ください

132
00:13:53,040 --> 00:13:55,680
機能メンバーシップ(feature membership)と
言われる要素があります

133
00:13:55,680 --> 00:14:02,320
それは型により機能(feature)が
所有される関係性です

134
00:14:02,320 --> 00:14:09,730
パイロット実装を調べるとき
後ほどこれらの要素を再度確認します

135
00:14:09,730 --> 00:14:11,740
パート1は以上だと思います

136
00:14:11,740 --> 00:14:16,880
たしかに他にもたくさんの項目がありますが
今回の開封では対象外です

137
00:14:16,880 --> 00:14:20,225
クリスチャン、パート2とパート3はどうでしょうか？

138
00:14:20,639 --> 00:14:25,600
私のスクリーンを再度見てみましょう

139
00:14:25,600 --> 00:14:34,618
いくつかのPDFを準備しました

140
00:14:34,618 --> 00:14:42,490
パート2は言語に関してです

141
00:14:42,490 --> 00:14:49,140
OMGシステムズモデリング言語
バージョン2.0の仕様書です

142
00:14:49,140 --> 00:14:58,109
2017年のRFPに応じて提出されたものです

143
00:14:58,109 --> 00:15:05,199
ティムが示したような同様な
セクションを見てみましょう

144
00:15:05,199 --> 00:15:09,790
400ページ近くあります

145
00:15:09,790 --> 00:15:20,659
言語の仕様をまとめることが
どれだけ大変か想像できるでしょう

146
00:15:20,659 --> 00:15:27,440
7.7章を見てみたいと思います

147
00:15:27,440 --> 00:15:34,160
見つけるのに数分かかるかもしれません

148
00:15:34,160 --> 00:15:43,800
7.7章はパート(parts)に関する章です

149
00:15:43,800 --> 00:15:48,290
SysML v1にも同様の概念はありました

150
00:15:48,290 --> 00:15:52,560
しかしSysML v1から変更があり
ブロック(block)はもう使用しません

151
00:15:52,560 --> 00:15:57,199
SysML v1のブロック(block)は
SysML v2でパート定義(part definition)です

152
00:15:57,199 --> 00:16:04,720
これにより定義(definition)と使用法(usage)の
概念を言語全体にもたらします

153
00:16:04,720 --> 00:16:12,180
属性や振る舞い等についても同様に
定義(definition)と使用法(usage)の概念があります

154
00:16:12,180 --> 00:16:16,079
すべての概念について非常に似ています

155
00:16:16,079 --> 00:16:22,480
このダイアグラムで抽象的な
シンタクスを見つけることができます

156
00:16:22,480 --> 00:16:27,990
これは定義(definition)と使用法(usage)の
間のコンテキストを与えます

157
00:16:27,990 --> 00:16:32,750
アイテム定義やパート定義がどのように
定義(definition)と関連するかといったことや

158
00:16:32,750 --> 00:16:38,720
アイテム使用法とパート使用法がどのように
使用法(usage)と関連するのかといったことや

159
00:16:38,720 --> 00:16:42,240
そして二つの側面がどのように共に機能しているのか
といったことと同様にコンテキストも与えます

160
00:16:42,240 --> 00:16:47,921
これはあまり馴染みのない考えであり
目の前の派手なものの背後にあります

161
00:16:47,921 --> 00:16:49,279
しかし信じてください

162
00:16:49,279 --> 00:16:58,560
たくさんの優秀な人たちが
十分に頭を使って考えたものです

163
00:16:58,560 --> 00:17:05,279
彼らはSysMLからUMLのメタモデルを
取り除くことを決めました

164
00:17:05,279 --> 00:17:13,660
そのことが不可能というのではなく
より明確な基盤となるためです

165
00:17:13,660 --> 00:17:20,669
そしてSysML v2がそうなるように
より具体的で正確になるのです

166
00:17:20,669 --> 00:17:25,490
残りの384ページを見ることができます

167
00:17:25,490 --> 00:17:31,360
しかしそのためには24時間の
ポッドキャストセッションが必要です

168
00:17:31,360 --> 00:17:35,640
私たちはそれにより
うんざりさせたくありません

169
00:17:35,640 --> 00:17:40,390
そのため私たちはリリースの中の
第三のドキュメントに移ろうと思います

170
00:17:40,390 --> 00:17:46,860
第三のドキュメントはAPIです

171
00:17:46,860 --> 00:18:01,270
モデリング言語の数か月後に発行されたAPIのRFP
に応じてリリースされたAPIのドキュメントです

172
00:18:01,270 --> 00:18:09,700
APIはモデリング言語とともに開発されます

173
00:18:09,700 --> 00:18:14,739
その利点は数分後に確認します

174
00:18:14,739 --> 00:18:20,720
仕様書の7.5.2章に戻りましょう

175
00:18:20,720 --> 00:18:27,440
それは言語仕様としてはサイズが小さいです

176
00:18:27,440 --> 00:18:33,459
7.5章は要素のバージョン管理に関しての章です

177
00:18:33,459 --> 00:18:37,130
APIはサービスを提供します

178
00:18:37,130 --> 00:18:40,880
その中の一つがバージョン管理です

179
00:18:40,880 --> 00:18:50,640
7.5.2章では抽象的なシンタクスを確認します

180
00:18:50,640 --> 00:18:58,570
それはプロジェクトと結びついている
ダイアグラムを示します

181
00:18:58,570 --> 00:19:07,840
つまりここではモデルの先頭やルートを
プロジェクトと呼んでいます

182
00:19:07,840 --> 00:19:12,559
プロジェクトはいくつかの
要素の識別子を持っています

183
00:19:12,559 --> 00:19:27,930
識別子は複数のバージョンを持っています
要素の識別子はレコード(Record)と呼ばれます

184
00:19:27,930 --> 00:19:31,919
そしてダイアグラムの最後の要素は
コミット(Commit)です

185
00:19:31,919 --> 00:19:38,100
これはgitのようなものです
コミット(Commit)はチェンジセットを持ちます

186
00:19:38,100 --> 00:19:42,960
チェンジセットはいくつかの
要素のバージョンを持ちます

187
00:19:42,960 --> 00:19:55,560
先日INCOSEのドイツのシンポジウムTdSEにて
私たちが紹介したパイロット実装をお見せします

188
00:19:55,560 --> 00:20:06,159
そこで概念証明(PoC)をして
どれほど簡単に機能するのかを示します

189
00:20:06,159 --> 00:20:09,840
これですべてのドキュメントを見終わりました

190
00:20:09,840 --> 00:20:14,000
さあ、インストールフォルダを見てみましょう

191
00:20:14,850 --> 00:20:19,627
実際のものですね

192
00:20:19,627 --> 00:20:21,540
画面を共有します

193
00:20:21,540 --> 00:20:28,480
こちらです

194
00:20:28,480 --> 00:20:36,320
リリースフォルダを解凍したら
インストールフォルダがあります

195
00:20:36,320 --> 00:20:41,267
インストールフォルダには
二つのサブフォルダがあります

196
00:20:41,267 --> 00:20:46,549
ひとつはEclipseのパイロット実装
もう一つはJupyteです

197
00:20:46,549 --> 00:20:50,591
Eclipseを開いてみます

198
00:20:50,591 --> 00:20:54,640
Eclipseフォルダの中には
READMEファイルがあります

199
00:20:54,640 --> 00:21:01,039
そこにはSysML v2のパイロット実装の
インストール方法がわかりやすく書いてあります

200
00:21:01,039 --> 00:21:05,520
数日前に動かしたときは
うまくいきました

201
00:21:05,520 --> 00:21:13,360
PDFに書かれているように
インストール前にEclipseが必要です

202
00:21:13,360 --> 00:21:22,190
Eclipseのインストール方法は書かれていませんが
eclipse.orgのサイトからダウンロードするだけです

203
00:21:22,190 --> 00:21:27,760
実際にはインストーラをダウンロードし
それを起動しますが一つ注意点があります

204
00:21:27,760 --> 00:21:31,520
インストールの際にインストールしたい
エディションを聞かれます

205
00:21:31,520 --> 00:21:37,090
私の場合はモデリングをするため
"Eclipse Modeling Tools"を選びます

206
00:21:37,090 --> 00:21:45,039
しかし実際にはJDKさえ含んでいれば
どの版でも大丈夫です

207
00:21:45,039 --> 00:21:51,100
Eclipseをインストールしたら
READMEの指示に従います

208
00:21:51,100 --> 00:21:56,640
ダウンロードには時間がかかるので
すでに実行済みです

209
00:21:56,640 --> 00:22:02,480
さあ、準備ができましたので
Eclipceに移りましょう

210
00:22:02,480 --> 00:22:05,840
画面を共有します

211
00:22:05,840 --> 00:22:14,559
Eclipseフォルダが
PCのどこかにあります

212
00:22:14,559 --> 00:22:19,360
こちらです

213
00:22:19,360 --> 00:22:24,960
こちらがEclipseのIDEです

214
00:22:24,960 --> 00:22:36,000
Eclipseに詳しくなければ、READMEにある
preferenceがどこかわからないでしょう

215
00:22:36,000 --> 00:22:40,790
それはウィンドウメニューにあります

216
00:22:40,790 --> 00:22:50,720
preferenceがそこにあるとは
予想できないでしょう

217
00:22:50,720 --> 00:22:55,340
インストールしたら
三つのフォルダがあります

218
00:22:55,340 --> 00:22:58,159
kerml、sysml、sysml libraryです

219
00:22:58,159 --> 00:23:12,720
クリスチャンが示した通り、sysmlパッケージ
には多くの例とトレーニング資料があります

220
00:23:12,720 --> 00:23:22,000
自身のモデルを作ることもできます
PDFに新プロジェクトの作り方があります

221
00:23:22,000 --> 00:23:29,660
またそれをXtext形式に変換する必要があります
そのあたりもすべてPDFに書かれています

222
00:23:29,660 --> 00:23:36,310
最終的には空のプロジェクトができます
私は"simple system"というものを作りました

223
00:23:36,310 --> 00:23:49,250
プロジェクトの中に*.sysmlという
新しいファイルを作ります

224
00:23:49,250 --> 00:23:55,520
「SysMLをプログラミングする」
とでも言えばよいですかね？

225
00:23:55,520 --> 00:24:01,460
SysMLのソースコードですかね？
ソースコードのようなものでしょう

226
00:24:01,460 --> 00:24:06,720
そしてテキスト表記のSysML v2の
シンタクスの描画のされ方もPDFにあります

227
00:24:06,720 --> 00:24:10,889
SysML v2導入のPDFにあります

228
00:24:10,889 --> 00:24:17,330
また、SysMLv2のシンタクスの
テキスト表記の説明も含まれています

229
00:24:17,330 --> 00:24:22,110
私はとても単純なモデルを作りました

230
00:24:22,110 --> 00:24:26,870
こちらはパート定義(part definition)です
SysML v1のブロック(block)です

231
00:24:26,870 --> 00:24:32,170
"simple system"のモデルであり
属性(attribute)にReal型のmassがあります

232
00:24:32,170 --> 00:24:39,360
その型の三つのパート(part)を包含する
一つのパート(part)を作りました

233
00:24:39,360 --> 00:24:40,640
とても単純な構造です

234
00:24:40,640 --> 00:24:47,120
"my system"というパート(part)は
p1、p2、p3というパート(part)を持ちます

235
00:24:47,120 --> 00:24:57,679
SysML v2コードのようなものをクリックすると
Eclipseのアウトラインビューが見えます

236
00:24:57,679 --> 00:25:01,200
モデル構造があります

237
00:25:01,200 --> 00:25:10,630
さきほどPDFで確認した
メタモデルの型があります

238
00:25:10,630 --> 00:25:13,520
例えば、たくさんの機能メンバーシップ
(feature membership)があります

239
00:25:13,520 --> 00:25:23,840
この関係性は機能(feature)をオーナーである
パート定義や使用法にリリースします

240
00:25:23,840 --> 00:25:28,559
私たちがファイルをどのレベルで
調べるかに依存しています

241
00:25:28,559 --> 00:25:36,950
そして描画することも可能です

242
00:25:36,950 --> 00:25:41,919
READMEのPDFにはPlantUMLの
インストール方法があります

243
00:25:41,919 --> 00:25:50,210
これはモデリングツールではなく
UML用の描画ツールです

244
00:25:50,210 --> 00:25:54,770
SysML v2にも使用できます

245
00:25:54,770 --> 00:25:58,720
インストールしたら
PlantUMLビューが開きます

246
00:25:58,720 --> 00:26:03,042
そのためにはウィンドウメニューで
選択しなければなりません

247
00:26:03,042 --> 00:26:11,200
PlantUMLウィンドウを選びます

248
00:26:11,200 --> 00:26:24,170
そうすればSysML v2のソースコードを
グラフィカル表記で表示できます

249
00:26:24,170 --> 00:26:28,720
このSysML v2のグラフィカル表記は
最終版ではありません

250
00:26:28,720 --> 00:26:35,949
現状のSysML v2を描画するためのものであり
最終的に確定したものではありません

251
00:26:35,949 --> 00:26:45,120
PlantUMLで表記可能なことは
すばらしいことです

252
00:26:45,120 --> 00:26:48,320
こちらでEclipseは以上です

253
00:26:48,320 --> 00:26:55,500
もう一つのSysMLパイロット実装の
インストールフォルダがあります

254
00:26:55,500 --> 00:26:59,120
こちらはJupyterLabベースです

255
00:26:59,120 --> 00:27:03,050
クリスチャンの方がJupyterに詳しいので
説明はクリスチャンに任せます

256
00:27:03,520 --> 00:27:07,360
本当に私の方が詳しいですか？

257
00:27:07,360 --> 00:27:09,539
まあ、そうかもしれませんね

258
00:27:09,539 --> 00:27:13,404
では別のパイロット実装の
説明に移りましょう

259
00:27:13,404 --> 00:27:16,618
ティムが言っていたように
第二のパイロット実装があります

260
00:27:16,618 --> 00:27:20,260
それはJupyterLabです
Jupyter Notebookの後継です

261
00:27:20,260 --> 00:27:26,140
ユーザの観点から見たら
いずれも同じものです

262
00:27:26,140 --> 00:27:28,780
二つの前提条件があります

263
00:27:28,780 --> 00:27:34,480
JaveとPython関連のインストールが必要です
例えばAnacondaのようなものが必要です

264
00:27:34,480 --> 00:27:41,279
バッチファイルや別プラットフォーム用の
シェルスクリプトがあります

265
00:27:41,279 --> 00:27:45,759
これによりJupyter Notebookを
非常に簡単にインストールできます

266
00:27:45,759 --> 00:27:55,600
ただしWindowsの場合は管理者権限で
バッチファイルを実行してください

267
00:27:55,600 --> 00:27:59,360
そうしたら問題はありません

268
00:27:59,360 --> 00:28:06,411
もう一度画面を共有します

269
00:28:06,411 --> 00:28:18,080
今準備しているのはコンソール(コマンドライン)です
"jupyter lab"とタイプして実行します

270
00:28:18,080 --> 00:28:22,399
そうするとウェブサービスが開始します

271
00:28:22,399 --> 00:28:27,120
私のブラウザでは数分すると
ウィンドウが出てきます

272
00:28:27,120 --> 00:28:35,050
ウィンドウが出てくるのをライブでお見せします

273
00:28:35,050 --> 00:28:41,360
動画視聴者は見れるはずです

274
00:28:41,360 --> 00:28:44,960
まだロード中です

275
00:28:44,960 --> 00:28:47,229
これがJupyterLabです

276
00:28:47,229 --> 00:28:55,070
SysMLの新しいノートブックを作ります

277
00:28:55,070 --> 00:28:59,200
新しいノートブックを準備しています

278
00:28:59,200 --> 00:29:06,512
この間にいくつかコピーできますが…

279
00:29:06,512 --> 00:29:10,960
おかしいですね
前はうまくいったのですが

280
00:29:10,960 --> 00:29:13,039
なるほど、少し待ち時間が必要でしたね

281
00:29:13,039 --> 00:29:20,240
バックグラウンドでたくさん
ロードしているからだと思います

282
00:29:20,240 --> 00:29:26,679
ポッドキャストの動画のエンコーディングも
しているのでCPUの負荷がかかっているのでしょう

283
00:29:27,679 --> 00:29:31,679
重要なことは、これはまだ
パイロット実装だということです

284
00:29:31,679 --> 00:29:37,400
パフォーマンスやユーザインターフェース
に関しては最適化されていません

285
00:29:37,400 --> 00:29:39,120
まだパイロット実装だからです

286
00:29:39,450 --> 00:29:46,979
ですので試行錯誤の痕跡は残っています

287
00:29:46,979 --> 00:29:49,200
続きを行いましょう
こちらが新しいノートブックです

288
00:29:49,200 --> 00:29:56,092
JupyterLabやJupyter Notebookを
ご存じであればコードを入力できます

289
00:29:56,092 --> 00:30:03,600
この例ではSysMLのテキスト表記を入力します

290
00:30:03,600 --> 00:30:07,279
そして、ああ大丈夫ですね

291
00:30:07,279 --> 00:30:09,746
気づいた人もいるかもしれません

292
00:30:09,746 --> 00:30:21,440
先ほどまで全てが白黒でしたが、メタモデルの
シンタクスがロードされてハイライトされました

293
00:30:21,440 --> 00:30:32,240
これから"show"メソッドをお見せします

294
00:30:32,240 --> 00:30:36,159
出てきました

295
00:30:36,159 --> 00:30:41,039
コマンド実行すると

296
00:30:41,039 --> 00:30:46,312
バックグラウンドで何か実行して…
うまくいきませんね

297
00:30:46,642 --> 00:30:50,364
"MBSEPodcast"を表示するために
引数が必要だと思います

298
00:30:50,844 --> 00:30:53,190
そのとおりです、ティム

299
00:30:53,360 --> 00:30:55,130
例えばパッケージ名ですね

300
00:30:55,257 --> 00:31:06,159
そのとおり、"MBSEPodcast"

301
00:31:10,600 --> 00:31:13,600
そうしたらバックグラウンドで
何かが実行されています

302
00:31:13,600 --> 00:31:21,080
そして少し時間がかかります

303
00:31:21,080 --> 00:31:24,210
何かスペルミスをしていますか？

304
00:31:28,240 --> 00:31:33,743
「参照が解決されなかった」
なぜでしょう？

305
00:31:33,743 --> 00:31:38,080
まあいいでしょう
以前はうまくいきました

306
00:31:38,080 --> 00:31:44,000
うまくいったことにしましょう
これがライブ配信です

307
00:31:44,000 --> 00:31:55,670
本来表示されるべきものは
Eclipseで表示したものと同じ構造です

308
00:31:55,670 --> 00:32:05,230
JupyterLabがバックグラウンドで行っていることは
ソースコード、つまりテキスト表記の解決です

309
00:32:05,230 --> 00:32:10,240
モデルとすべてのオブジェクトをビルドします

310
00:32:10,240 --> 00:32:19,440
さらにメンバーシップや機能メンバーシップ等を
バックグラウンドで含んでいきます

311
00:32:19,440 --> 00:32:34,799
次に実行するのは"publish"コマンドです

312
00:32:34,799 --> 00:32:41,519
成功したかどうか確認してみましょう

313
00:32:41,519 --> 00:32:45,200
ふむ、解決されていませんね

314
00:32:45,200 --> 00:32:49,249
括弧が必要でしたっけ？

315
00:32:49,679 --> 00:32:52,429
まずコードを実行しなければなりません

316
00:32:53,039 --> 00:32:57,840
なるほど

317
00:33:01,120 --> 00:33:03,569
これであなたはJupyterの
エキスパートですね

318
00:33:03,919 --> 00:33:07,387
あなたが正しいことを教えてくれた

319
00:33:07,387 --> 00:33:09,629
さて、うまく動きました

320
00:33:09,629 --> 00:33:15,530
見てください、驚きです

321
00:33:15,530 --> 00:33:17,679
こちらがモデル構造です

322
00:33:17,679 --> 00:33:22,750
私たちがタイプしたりペーストした
以外のものが見えています

323
00:33:22,750 --> 00:33:27,350
import宣言は明白です
そこに貼られています

324
00:33:27,350 --> 00:33:30,426
Memberships、Superclassingがあります

325
00:33:30,426 --> 00:33:34,250
さらにそこには、FeatureMembership
FeatureTyping、Subsettingもあります

326
00:33:34,250 --> 00:33:42,370
ソースコードで事前に宣言された
全てのものはモデル構造として現れます

327
00:33:42,370 --> 00:33:51,360
それぞれに要素にUUIDが振られている
ことに気づいたかも知れません

328
00:33:51,360 --> 00:34:01,519
これはJupyterLabにモデルオブジェクトの
インスタンスがあることを示します

329
00:34:01,519 --> 00:34:13,040
あとはSysML v2 APIを使用してモデルを
リポジトリに公開(publish)するだけです

330
00:34:13,040 --> 00:34:16,399
こちらは時間がかかります
最適化されていないためです

331
00:34:16,399 --> 00:34:27,760
この例、もしくは非常に類似した例のような
単純なモデルでも膨大な行数のJSONが実行されます

332
00:34:27,760 --> 00:34:33,509
バックグラウンドで起こっていることは
たくさんあり、今後最適化されるでしょう

333
00:34:33,509 --> 00:34:46,879
このモデルを私のコンピュータから
SysMLv2リポジトリへの転送処理は実行中です

334
00:34:46,879 --> 00:34:58,240
このリポジトリはIntercaxが管理しており
IntercaxはSysML v2 APIに多大な貢献をしています

335
00:34:58,240 --> 00:35:03,620
ティム、リポジトリについて
他にできることはありますか？

336
00:35:04,240 --> 00:35:11,839
はい、私たちはブラウザ経由で
リポジトリにアクセスできます

337
00:35:11,839 --> 00:35:14,720
とても素晴らしいです

338
00:35:14,720 --> 00:35:24,080
もう一度私の画面を共有します

339
00:35:28,560 --> 00:35:36,640
URLはこちらです
http://sysml2.intercax.com:9000/docs

340
00:35:36,640 --> 00:35:44,960
SysML v2 APIのREST/HTTP
バインディングが見つかります

341
00:35:44,960 --> 00:35:48,880
OSLCバインディングも利用できます

342
00:35:48,880 --> 00:35:52,560
それがパイロット実装上で機能しています

343
00:35:52,560 --> 00:35:58,640
今回か次回のリリースで
こちらが公開され利用できる予定です

344
00:35:58,640 --> 00:36:01,951
ともかく、こちらは
REST/HTTPバインディングです

345
00:36:01,951 --> 00:36:08,330
Swaggerを使って
メソッドにアクセスします

346
00:36:08,330 --> 00:36:10,129
プロジェクトの"publish"は
完了しましたか？

347
00:36:10,419 --> 00:36:11,149
はい、完了しました

348
00:36:11,359 --> 00:36:14,780
完了しましたか？
わかりました

349
00:36:14,780 --> 00:36:25,520
例えば全プロジェクトのリストを取得できます
どのように機能するか見てみましょう

350
00:36:25,520 --> 00:36:29,359
公開サーバなので、"publish"すれば
誰もが自由に使用することができます

351
00:36:29,359 --> 00:36:32,045
たくさんのものがあります

352
00:36:32,045 --> 00:36:34,880
応答が返ってきました

353
00:36:34,880 --> 00:36:41,320
”PictureTaking"、"1c-Parts"、
10月30日に"Tree Redefinition"等があります

354
00:36:41,320 --> 00:36:48,000
一番下に数分前に"publish"された
"MBSEPodcast"プロジェクトがあります

355
00:36:48,000 --> 00:36:56,560
MBSE Podcastの前にTdSEに先週参加しており
そこでもクリスチャンと私が"publish"しました

356
00:36:56,560 --> 00:36:58,620
そして識別子があります

357
00:36:58,620 --> 00:37:00,800
こちらがプロジェクト
固有の識別子です

358
00:37:00,800 --> 00:37:05,599
こちらは必要なので
コピーします

359
00:37:05,599 --> 00:37:09,630
別の呼び出しのために
下にスクロールします

360
00:37:09,630 --> 00:37:17,890
このプロジェクトの
コミットを取得しました

361
00:37:17,890 --> 00:37:25,839
プロジェクトのIDが必要なので
貼り付けして実行します

362
00:37:25,839 --> 00:37:29,120
返事がありました

363
00:37:29,120 --> 00:37:33,520
一つのコミットがあります

364
00:37:33,520 --> 00:37:44,050
APIを通じてモデル情報を取得するには
コミットIDが必要です

365
00:37:44,050 --> 00:37:50,240
こちらはプロジェクトIDと
本コミットのコミットIDです

366
00:37:50,240 --> 00:37:53,599
そうしたら呼び出しが可能です

367
00:37:53,599 --> 00:37:56,110
さらに下に下がります

368
00:37:56,110 --> 00:38:07,200
例えば、プロジェクトとコミットにより
エレメントやルートエレメント等を取得しています

369
00:38:07,200 --> 00:38:10,320
全エレメントを取得するのは時間がかかるため
朝のうちにしようと試みました

370
00:38:10,320 --> 00:38:16,127
そうしたらサーバを壊してしまいました

371
00:38:16,127 --> 00:38:22,240
そのため再度試してみます
まずプロジェクトIDが必要です

372
00:38:22,240 --> 00:38:27,359
それはクリップボードにあります
そしてコミットIDが必要です

373
00:38:27,359 --> 00:38:37,839
こちらです
貼り付けします

374
00:38:37,839 --> 00:38:46,400
少し時間がかかるため
うまくいくか一緒に見ましょう

375
00:38:46,400 --> 00:38:48,800
まだロードしています

376
00:38:48,800 --> 00:38:57,040
JASONの応答です
とても長いです

377
00:38:57,040 --> 00:39:03,359
たくさんの空のフィールドがあります
これらは最適化可能です

378
00:39:03,359 --> 00:39:14,589
そしてどこかに"MBSEPodcast"パッケージがあります
それはモデルのルートエレメントです

379
00:39:14,589 --> 00:39:17,040
もし呼び出しをしたら
全てのエレメントを取得できます

380
00:39:17,040 --> 00:39:27,130
パート(part)やパート定義(part definition)等を
見つけることができます

381
00:39:27,130 --> 00:39:32,079
その環境で遊んでみたり、うまく機能している
のを見ることは良いことです

382
00:39:32,079 --> 00:39:34,480
クリスチャン
先週のことは話しましたか？

383
00:39:34,480 --> 00:39:38,320
私たちはAPIに関して
すばらしいデモをしましたよね

384
00:39:38,320 --> 00:39:41,610
まだ数分あるので、簡単に
説明してもらえませんか？

385
00:39:41,975 --> 00:39:42,975
わかりました

386
00:39:45,520 --> 00:39:50,520
このセッションですでに二回言いました

387
00:39:50,520 --> 00:39:56,960
ドイツのINCOSE国際シンポジウムで
私たちはデモをしました

388
00:39:56,960 --> 00:40:01,890
そのシンポジウムで発表したことと
ほぼ同じことを本セッションで示しています

389
00:40:01,890 --> 00:40:10,400
そちらのために私たちは
Eclipseの実装から始めました

390
00:40:10,400 --> 00:40:17,260
その後にJupyter Notebookを作り
モデルを公開(publish)しました

391
00:40:17,260 --> 00:40:27,949
つまりモデルを公開(publish)したり
そのリポジトリを見るということをしました

392
00:40:27,949 --> 00:40:30,130
大したことではありません

393
00:40:30,130 --> 00:40:32,480
私たちはコードを数行
書くことにしました

394
00:40:32,480 --> 00:40:41,200
私たちはどのようにその他のツールを使って
他のエンジニアリング領域と協調できるか考えました

395
00:40:41,200 --> 00:40:54,530
もっともよく知られているツールは
Microsoft Excelで、それを採用しました

396
00:40:54,530 --> 00:41:05,680
Microsoft ExcelはREST呼び出しができたり
HTTPのPOSTコールができることを知りました

397
00:41:05,680 --> 00:41:15,970
私たちはユースケースを想定しました

398
00:41:15,970 --> 00:41:27,359
システムズエンジニアがモデルを
リポジトリに公開し

399
00:41:27,359 --> 00:41:33,760
他の領域のエンジニアがツールを
使ってその情報を読み出します

400
00:41:33,760 --> 00:41:39,800
今回のツールはExcelです

401
00:41:39,800 --> 00:41:49,680
HTTP経由でリポジトリにアクセスし
情報を更新しリポジトリに戻します

402
00:41:49,680 --> 00:41:57,930
ライブで実演もできますが
ティムも言ったように時間がかかります

403
00:41:57,930 --> 00:42:04,240
そのため動画をお見せします

404
00:42:04,240 --> 00:42:14,199
ここはすでに説明したEclipseやJupyter
Notebookのことなので少し先に進みます

405
00:42:14,199 --> 00:42:24,049
情報読み出す興味深い箇所は
動画の後ろの方です

406
00:42:24,049 --> 00:42:26,800
こちらは整数の42です

407
00:42:26,800 --> 00:42:30,000
ドメインエンジニアがこう言いました
「42 は私の欲しい数字ではない」

408
00:42:30,000 --> 00:42:35,760
「パスワードのような12345という数字だ」

409
00:42:35,760 --> 00:42:43,159
APIを送り返すボタンをここに作りました

410
00:42:43,159 --> 00:42:49,599
この例のようなものは
数秒前にお見せしました

411
00:42:49,599 --> 00:42:55,100
あるコミットがある前に

412
00:42:55,100 --> 00:43:03,279
そしてExcelから公開(publish)を
実行した後に

413
00:43:03,279 --> 00:43:05,359
全てのコミットを再度呼び出します

414
00:43:05,359 --> 00:43:09,760
プロジェクト上に二つのコミットが
あることがわかります

415
00:43:09,760 --> 00:43:20,190
そして整数値のプロパティをもつ
特別なエレメントが見つかります

416
00:43:20,190 --> 00:43:27,570
そしてついに、12345という値を
リポジトリ上に見つけることができました

417
00:43:27,570 --> 00:43:39,359
ひょっとしたら、Excelからリポジトリへの
変換は大したことないと思うかもしれません

418
00:43:39,359 --> 00:43:43,359
しかし重要なことは
私がプログラマではないということです

419
00:43:43,359 --> 00:43:51,289
実際には、論文等で使用したため
プログラミング言語を知っています

420
00:43:51,289 --> 00:43:54,240
プログラムの仕方はわかりますが
プログラマではありません

421
00:43:54,240 --> 00:43:58,720
インターネットがどのような
仕組みかは知っています

422
00:43:58,720 --> 00:44:07,119
Visual Basicのプログラミングの経験なしでしたが
数時間ほどで作り上げることができました

423
00:44:07,119 --> 00:44:10,560
概念実証(PoC)を提示することができました

424
00:44:10,560 --> 00:44:18,630
それは言語がAPIかもしれないことよりも
重要なことであるかもしれません

425
00:44:18,630 --> 00:44:37,049
APIと概念実証(PoC)を通じて、モデルベース環境の
異なるツールの統合が簡単であると示せたためです

426
00:44:37,049 --> 00:44:39,709
このことはこれまで
実現できなかったことです

427
00:44:39,709 --> 00:44:44,020
これまでは常に、ツールに合わせた
独自の統合をしなければなりませんでした

428
00:44:44,020 --> 00:44:51,940
これはまさに「MBSEのサイロ化」であり
「SysMLのサイロ化」です

429
00:44:51,940 --> 00:44:57,180
さらには「MATLAB Simulinkのサイロ化」です

430
00:44:57,180 --> 00:45:04,640
モデル交換(Model Exchange)や

431
00:45:04,640 --> 00:45:08,110
何と言いましたっけ？
モデル変換(Model Transformation)ですね

432
00:45:08,110 --> 00:45:11,280
モデル変換(Model Transformation)がこれまで
ほとんど達成されてきませんでした

433
00:45:11,280 --> 00:45:18,870
私たちが先ほど示したように
APIの実装がそれを可能にします

434
00:45:18,870 --> 00:45:26,040
モデル変換(Model Transformation)をして、他の
用途にエレメントを使用することが可能となります

435
00:45:26,040 --> 00:45:30,780
こちらに関しては、近い将来
ティムと私で何かお見せします

436
00:45:30,780 --> 00:45:40,699
Modelicaベースのシミュレーションを用いて
SysMLの複合構造から実際の重量を取得します

437
00:45:40,699 --> 00:45:45,759
とても簡単に実現できます

438
00:45:49,030 --> 00:45:52,661
以上です

439
00:45:52,661 --> 00:45:54,319
以上がSysML v2の開封動画となります

440
00:45:54,319 --> 00:45:58,620
45分も使ってしまいましたね

441
00:45:58,620 --> 00:46:00,010
しかしとても価値のある
動画になったと思います

442
00:46:00,010 --> 00:46:03,330
がっかりさせないような
内容であることを願っています

443
00:46:03,330 --> 00:46:06,160
もっと詳細を知りたい方もいるでしょう

444
00:46:06,160 --> 00:46:12,880
すでに述べたように、SysML v2については
他のポッドキャストを投稿する予定です

445
00:46:12,880 --> 00:46:16,720
SysML v2の内容がより成熟した
タイミングになるとは思いますが

446
00:46:22,640 --> 00:46:26,000
何か言い忘れていましたかね？
ああ、そうでした

447
00:46:26,000 --> 00:46:30,590
パイロット実装に関する質問は
Googleグループに参加して質問ください

448
00:46:30,590 --> 00:46:38,400
動画の説明欄と私たちのサイトに
リンクを載せておきます

449
00:46:38,400 --> 00:46:41,399
そこで質問が可能です

450
00:46:41,399 --> 00:46:50,460
エドやパイロット実装のメンバが
すぐに回答してくれます

451
00:46:55,520 --> 00:46:58,319
次のエピソードは何でしたっけ？

452
00:46:59,119 --> 00:47:10,480
次のエピソードは少なくとも三週間以内の
12月15日にドイツ語で実施します

453
00:47:10,480 --> 00:47:13,839
初めてゲストをお招きします

454
00:47:13,839 --> 00:47:18,980
ジョセフ・ラッセルセンターという新しい研究所の
ディレクターのクリスチャン・ノイライターです

455
00:47:18,980 --> 00:47:24,640
オーストリアでディペンダブルな
システムオブシステムズを研究しています

456
00:47:24,640 --> 00:47:30,399
彼と会えることを
とても楽しみにしています

457
00:47:30,399 --> 00:47:38,380
そしてゲストを招いた回の
皆さんの反応にも興味があります

458
00:47:38,380 --> 00:47:39,680
本日は以上です

459
00:47:39,680 --> 00:47:42,550
忘れてはいけませんね

460
00:47:42,550 --> 00:47:44,940
信じてください
私たちはシステムズエンジニアです
